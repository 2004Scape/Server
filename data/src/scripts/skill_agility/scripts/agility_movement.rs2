// Delay and 'climb' to a coord, similar to ladders. 
// Generally used for net obstacles
[proc,agility_climb_up](int $xp, coord $coord)
anim(human_reachforladdertop, 0);
p_delay(0);
givexp(agility, $xp);
p_telejump($coord);

// force walk to a specific location, this isn't the 
// same as an exactmove 
[proc,agility_force_move](int $xp, seq $walk_seq, coord $dest)
bas_walk_f($walk_seq);
buildappearance(worn);
def_int $change_x = calc(coordx($dest) - coordx(coord));
def_int $change_z = calc(coordz($dest) - coordz(coord));
~agility_walk($change_x, $change_z);
givexp(agility, $xp);

[proc,agility_walk](int $change_x, int $change_z)
if($change_x = 0 & $change_z = 0) {
    ~update_bas;
    return;
}
def_int $move_x = 0;
def_int $move_z = 0;
if ($change_x >= 2) {
    $move_x = 2;
} else if ($change_x <= -2) {
    $move_x = -2;
} else { // +-1, 0
    $move_x = $change_x;
}
if ($change_z >= 2) {
    $move_z = 2;
} else if ($change_z <= -2) {
    $move_z = -2;
} else { // +-1, 0
    $move_z = $change_z;
}

// Perform movement and re-calc
p_teleport(movecoord(coord, $move_x, 0, $move_z));
$change_x = calc($change_x - $move_x);
$change_z = calc($change_z - $move_z);

// always 2 tick delay (one tile per tick, but 1t after you finish as well), recursive call
p_delay(1);
~agility_walk($change_x, $change_z);

[proc,update_course_varp](varp $varp_name, int $value)
// Update the course varp if the current value of the varp is $value - 1
