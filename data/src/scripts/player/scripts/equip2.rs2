[proc,try_equip](int $inv_slot)(boolean)
def_obj $equip_obj = inv_getobj(inv, $inv_slot);
def_int $equip_obj_num = inv_getnum(inv, $inv_slot);
if ($equip_obj = null) {
    return(false);
}
if (inv_itemspace2(worn, $equip_obj, $equip_obj_num, inv_size(worn)) > 0) { // overflowing only applies to stackable items, so we need no stackable checks
    return(false);
}
if (oc_wearpos($equip_obj) = null) {
    return(false);
}
inv_moveitem(inv, inv_96, $equip_obj, $equip_obj_num); // move equip item to dummy inv
if (~unequip_conflicts_space($equip_obj) = false) { // check if enough space
    inv_movetoslot(inv_96, inv, 0, $inv_slot); // move equip item back to original spot
    return(false);
}
~unequip_conflicts($equip_obj);
inv_movetoslot(inv_96, worn, 0, oc_wearpos($equip_obj)); // equip item :D
return(true);

[proc,unequip_conflicts_space](obj $equip_obj)(boolean)
def_int $wearpos1 = oc_wearpos($equip_obj);
def_int $wearpos2 = oc_wearpos2($equip_obj);
def_int $wearpos3 = oc_wearpos3($equip_obj);
def_int $conflicts = 0;
def_int $i = 0;
while ($i < inv_size(worn)) {
    def_obj $worn_obj = inv_getobj(worn, $i);
    def_int $worn_num = inv_getnum(worn, $i);
    if ($worn_obj ! null) {
        def_int $worn_wearpos1 = oc_wearpos($worn_obj);
        def_int $worn_wearpos2 = oc_wearpos2($worn_obj);
        def_int $worn_wearpos3 = oc_wearpos3($worn_obj);
        if (($wearpos1 ! null & ($wearpos1 = $worn_wearpos1 | $wearpos1 = $worn_wearpos2 | $wearpos1 = $worn_wearpos3))
        | ($wearpos2 ! null & ($wearpos2 = $worn_wearpos1 | $wearpos2 = $worn_wearpos2 | $wearpos2 = $worn_wearpos3))
        | ($wearpos3 ! null & ($wearpos3 = $worn_wearpos1 | $wearpos3 = $worn_wearpos2 | $wearpos3 = $worn_wearpos3))) {
            if (oc_stackable($worn_obj) = true) {
                if (inv_itemspace2(inv, $worn_obj, $worn_num, inv_size(inv)) > 0) {
                    return(false);
                }
                if (inv_total(inv, $worn_obj) < 0) { // if stackable item isnt in inv, then takes up a space
                    $conflicts = add($conflicts, 1);
                }
            } else {
                $conflicts = add($conflicts, 1);
            }
        }
    }
    $i = add($i, 1);
}
if ($conflicts > inv_freespace(inv)) {
    return(false);
}
return(true);

[proc,unequip_conflicts](obj $equip_obj)
def_int $wearpos1 = oc_wearpos($equip_obj);
def_int $wearpos2 = oc_wearpos2($equip_obj);
def_int $wearpos3 = oc_wearpos3($equip_obj);
def_int $conflicts = 0;
def_int $i = 0;
while ($i < inv_size(worn)) {
    def_obj $worn_obj = inv_getobj(worn, $i);
    def_int $worn_num = inv_getnum(worn, $i);
    if ($worn_obj ! null) {
        def_int $worn_wearpos1 = oc_wearpos($worn_obj);
        def_int $worn_wearpos2 = oc_wearpos2($worn_obj);
        def_int $worn_wearpos3 = oc_wearpos3($worn_obj);
        if (($wearpos1 ! null & ($wearpos1 = $worn_wearpos1 | $wearpos1 = $worn_wearpos2 | $wearpos1 = $worn_wearpos3))
        | ($wearpos2 ! null & ($wearpos2 = $worn_wearpos1 | $wearpos2 = $worn_wearpos2 | $wearpos2 = $worn_wearpos3))
        | ($wearpos3 ! null & ($wearpos3 = $worn_wearpos1 | $wearpos3 = $worn_wearpos2 | $wearpos3 = $worn_wearpos3))) {
            inv_moveitem(worn, inv, $worn_obj, $worn_num);
        }
    }
    $i = add($i, 1);
}

[debugproc,equiptest]
if (p_finduid(uid) = false) {
    return;
}
inv_clear(inv);
inv_clear(worn);
inv_add(inv, bronze_2h_sword, 1);
inv_add(inv, wooden_shield, 1);
inv_add(inv, bronze_arrow, 100);
inv_setslot(worn, ^wearpos_quiver, bronze_arrow, ^max_32bit_int);
inv_add(inv, logs, 25);