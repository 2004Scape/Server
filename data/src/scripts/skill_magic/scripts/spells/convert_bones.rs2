[if_button,magic:com_7] @magic_spell_convert_bones; //bones to bananas

[label,magic_spell_convert_bones]
// look for spell in db
def_dbrow $spell_data = ~get_spell_data(last_com);
// define spell runes
def_namedobj $rune1;
def_int $rune_count1;
def_namedobj $rune2;
def_int $rune_count2;
def_namedobj $rune3;
def_int $rune_count3;
// check runes
$rune1, $rune_count1, $rune2, $rune_count2, $rune3, $rune_count3 = ~check_spell_requirements($spell_data);
def_namedobj $null;
def_namedobj $product;
$null, $product = db_getfield($spell_data, magic_spell_table:convertobj, 0);
// check bones
if (~check_bones($product) = false) {
    mes("You aren't holding any bones!");
    return;
}
// play sound and anim
sound_synth(bones_to_bananas_all, 0, 0);
anim(seq_722, 0);
spotanim_pl(spotanim_141, 92, 0);
// delete runes and give xp
~delete_spell_runes($spell_data, $rune1, $rune_count1, $rune2, $rune_count2, $rune3, $rune_count3);
// No delay inbetween casts! But it does stop movement for 2 ticks

// this feels scuffed but this is the only way i can think of
// future proofing this :^(
[proc,check_bones](namedobj $product)(boolean)
def_int $i = 0; 
def_boolean $has_bones = false;
// 28 inv spaces
while($i < 28) {
    if (oc_category(inv_getobj(inv, $i)) = bones) {
        inv_del(inv, inv_getobj(inv, $i), 1);
        inv_add(inv, $product, 1);
        $has_bones = true;
    }
    $i = calc($i + 1);
}
return($has_bones);