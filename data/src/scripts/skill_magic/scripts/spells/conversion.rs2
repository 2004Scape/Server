// low alch
[opheldt,magic:com_10] @magic_spell_alch(seq_712, low_alchemy, spotanim_109, 4, 2);
// high alch
[opheldt,magic:com_26] @magic_spell_alch(seq_713, high_alchemy, spotanim_110, 6, 4);

[label,magic_spell_alch](seq $alch_anim, synth $sound, spotanim $spotanim, int $scale_value, int $delay)
// look for spell in db
def_dbrow $spell_data = ~get_spell_data(last_com);
// define spell runes
def_namedobj $rune1;
def_int $rune_count1;
def_namedobj $rune2;
def_int $rune_count2;
def_namedobj $rune3;
def_int $rune_count3;
// check runes
$rune1, $rune_count1, $rune2, $rune_count2, $rune3, $rune_count3 = ~check_spell_requirements($spell_data);
// check for additional reqs/restrictions, BEFORE deleting runes
// -
// if alchemy queue is active then return 
// else continue with the spell
if (getqueue(magic_alchemy_queue) > 0) {
    return;
}
// define object
def_namedobj $item = inv_getobj(inv, last_slot);
// prevent alchemy
if (~prevent_alchemy($item) = true) {
    return;
}
// play sound and anim
sound_synth($sound, 0, 0);
anim($alch_anim, 0);
spotanim_map($spotanim, coord, 92, 0);
// delete runes and give xp
~delete_spell_runes($spell_data, $rune1, $rune_count1, $rune2, $rune_count2, $rune3, $rune_count3);
// give 0.4x of item's value
inv_add(inv, coins, scale(4, 10, oc_cost($item)));
// occupy alchemy queue for 3 ticks if low alch, 5 ticks if high alch
// could just make delay equal to $scale_value - 2, but i think this is cleaner
queue(magic_alchemy_queue, $delay);

[queue,magic_alchemy_queue]

[proc,prevent_alchemy](namedobj $item)(boolean)
def_boolean $prevent_bool = true;
switch_namedobj($item) {
    case obj_1842 : mes("Nooooooo you can't alch ana! (unimplimented)");
    case coins : mes("Coins are already made of gold.");
    case default : 
        if (oc_param($item, unalchable) = ^true) {
            mes("You cannot use alchemy on that item.");
        } else {
            $prevent_bool = false;
        }
}
return ($prevent_bool);