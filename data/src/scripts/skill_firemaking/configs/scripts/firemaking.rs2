// trigger for logs on ground
[opobj4,_category_22]
def_obj $log = obj_type;
// check level first
def_int $level = oc_param(obj_type, levelrequire);
if (stat(firemaking) < $level) {
    mes("You need a Firemaking level of <tostring($level)> to burn <oc_name($log)>.");
    return;
}
// check if the coord is already occupied by an interactable loc
// unconfirmed
//if (~coord_contains_interactable_loc(obj_coord) = true | map_blocked = true) {
if (~coord_contains_interactable_loc(obj_coord) = true) {
    mes("You can't light a fire here.");
    return;
}
// check if they have tinderbox
if(inv_total(inv, tinderbox) < 0) {
    mes("You need a tinderbox to light a fire.");
    return;
}
@attempt_light_logs($log, false);

[opobju,logs]
if (last_item = tinderbox) {
    p_opobj(4);
} else {
    @nothing_interesting_happens;
}

// opheldu for logs is handled in fletching
[opheldu,tinderbox]
switch_category(oc_category(last_useitem)) {
    case category_22 : @light_logs_inv(last_useslot);
    case default : @nothing_interesting_happens;
}

[label,light_logs_inv](int $slot)
def_obj $log = inv_getobj(inv, $slot);
//mes(oc_debugname($log));
// check mems
if (oc_members($log) = true) {
    ~require_members_use_item;
}
// check level
def_int $level = oc_param($log, levelrequire);
if (stat(firemaking) < $level) {
    mes("You need a Firemaking level of <tostring($level)> to burn <oc_name($log)>.");
    return;
}
// check if the coord is already occupied by an interactable loc
// unconfirmed
//if (~coord_contains_interactable_loc(coord) = true | map_blocked = true) {
if (~coord_contains_interactable_loc(coord) = true) {
    mes("You can't light a fire here.");
    return;
}
// TODO: check area
//...

// delete item slot from inv
inv_delslot(inv, $slot);
// add obj to ground
obj_add(coord, $log, 1, ^lootdrop_duration);
@attempt_light_logs($log, true);

[label,attempt_light_logs](obj $log, boolean $from_opheld)
//mes("%action_delay: <tostring(%action_delay)>, %map_clock: <tostring(map_clock)>");
// 4t cycle
if (%action_delay < map_clock) {
    // stop player movement
    p_stopaction;
    // play anim
    anim(human_createfire, 0);
    // play sound
    sound_synth(tinderbox_strike, 0, 0);
    // mes
    mes("<tostring(map_clock)>: You attempt to light the logs.");
    %action_delay = calc(map_clock + 3);
    p_opobj(4);
} else if (%action_delay = map_clock) {
    // firemaking roll
    if(stat_random(stat(firemaking), 64, 512) = true) {
        %action_delay = calc(map_clock + 4);
        def_coord $fire_coord = obj_coord;
        // attempt to firemaking each direction
        // west
        ~firemaking_move($fire_coord, movecoord(coord, -1, 0, 0), $log, $from_opheld);
        // east
        ~firemaking_move($fire_coord, movecoord(coord, 1, 0, 0), $log, $from_opheld);
        // south
        ~firemaking_move($fire_coord, movecoord(coord, 0, 0, -1), $log, $from_opheld);
        // north
        ~firemaking_move($fire_coord, movecoord(coord, 0, 0, 1), $log, $from_opheld);
        // if fully blocked then just light the log and dont move
        @firemaking_success($fire_coord, $log);
    } else {
        // if fails, then reattempt to light
        // play anim
        p_stopaction;
        anim(human_createfire, 0);
        // play sound
        sound_synth(tinderbox_strike, 0, 0);
        %action_delay = calc(map_clock + 3);
        p_opobj(4);
    }
} else {
    // stop player movement
    p_stopaction;
    p_opobj(4);
}
// success roll low1=64|high1=512

[proc,firemaking_move](coord $fire_coord, coord $move_coord, obj $log, boolean $from_opheld)
// firemaking length: https://archive.is/zF5hb
// if player isnt standing on the log anymore, the fire is lit
//mes("coord: <~coord_tostring(coord)>, fire_coord: <~coord_tostring($fire_coord)>");
if (lineofwalk(coord, $move_coord) = true) {
    p_teleport($move_coord);
    // due to processing order, p_delay(1) in opheld scripts are actually p_delay(0)
    mes("<tostring(map_clock)>: Delay");
    if ($from_opheld = true) {
        p_delay(1);
    } else {
        p_delay(0);
    }
}
if (coord ! $fire_coord) { // & %action_delay < map_clock
    @firemaking_success($fire_coord, $log);
}

[label,firemaking_success](coord $fire_coord, obj $log)
// anim is stopped i think
anim(null, 0);
// lasts between 100 and 199 ticks, but locs update at the end of the tick, so we need to add 1
loc_add($fire_coord, loc_2732, 1, centrepiece_straight, ~random_range(100, 200));
// delete log
obj_del();
givexp(firemaking, oc_param($log, productexp));
sound_synth(fire_lit, 0, 0);
facesquare($fire_coord);
//mes("<tostring(map_clock)>, <tostring(%action_delay)>: The fire catches and the logs begin to burn.");
mes("<tostring(map_clock)>: The fire catches and the logs begin to burn.");

[debugproc,fmtest]
inv_clear(inv);
inv_add(inv, tinderbox, 1);
inv_add(inv, logs, 3);
inv_add(inv, magic_logs, 3);
inv_add(inv, yew_logs, 3);
inv_add(inv, maple_logs, 3);
inv_add(inv, willow_logs, 3);
inv_add(inv, oak_logs, 3);

[debugproc,fmbank]
~require_members_feature;
def_int $choice = ~p_choice2_header("Yes.", 1, "No.", 2, "This clears your bank. Continue?");
if ($choice = 2) {
    return;
}
inv_clear(bank);
inv_add(bank, tinderbox, 10);
inv_add(bank, logs, 10000);
inv_add(bank, magic_logs, 10000);
inv_add(bank, yew_logs, 10000);
inv_add(bank, maple_logs, 10000);
inv_add(bank, willow_logs, 10000);
inv_add(bank, oak_logs, 10000);

[proc,coord_contains_interactable_loc](coord $coord)(boolean)
loc_findallzone($coord);
while (loc_findnext = true) {
    // TODO: check if loc is interactable
    if (loc_coord = $coord & compare(lc_desc(loc_type), "null") = ^true) {
        return (true);
    }
}
return (false);