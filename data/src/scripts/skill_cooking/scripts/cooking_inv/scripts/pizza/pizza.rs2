[opheldu,pizza_base]
switch_obj (last_useitem) {
    case tomato : @make_incomplete_pizza;
    case cheese : mes("I should add the tomato first.");
    case pineapple_ring, anchovies, cooked_meat, cooked_chicken : mes("I need to add the tomato and cheese first.");
    case default : @nothing_interesting_happens;
};

[opheldu,tomato]
switch_obj  (last_useitem) {
    case pizza_base : @make_incomplete_pizza;
    case bowl_empty : @make_bowl_mixture(last_slot);
    case chopped_onion, chopped_ugthanki, chopped_ugthanki_onion : @make_bowl_mixture2(last_slot, last_useslot);
    case chopped_tomato, chopped_ugthanki_tomato, chopped_onion_tomato : mes("This mixture already contains enough <lowercase(oc_name(last_useitem))>.");
    case incomplete_pizza : mes("I think it's already got enough tomato on.");
    case default : @nothing_interesting_happens;
};

[opheldu,cheese]
switch_obj  (last_useitem) {
    case pizza_base : mes("I should add the tomato first.");
    case incomplete_pizza : @make_uncooked_pizza;
    case default : @nothing_interesting_happens;
};

[opheldu,incomplete_pizza]
switch_obj  (last_useitem) {
    case tomato : mes("I think it's already got enough tomato on.");
    case cheese : @make_uncooked_pizza;
    case default : @nothing_interesting_happens;
};

[opheldu,uncooked_pizza]
switch_obj  (last_useitem) {
    case pineapple_ring, anchovies, cooked_meat, cooked_chicken : ~uncooked_pizza_message(last_useslot);
    case default : @nothing_interesting_happens;
};

[opheldu,pineapple_ring]
~use_topping_on_pizza;

[opheldu,pineapple_chunks]
~use_topping_on_pizza;

[opheldu,anchovies]
~use_topping_on_pizza;

[opheldu,pizza]
switch_obj  (last_useitem) {
    case pineapple_ring, pineapple_chunks, anchovies, cooked_meat, cooked_chicken : @make_pizza_with_topping(last_useslot);
    case default : @nothing_interesting_happens;
};


//--- procs for handling opheldu stuff ---
[proc,use_topping_on_pizza]
switch_obj (last_useitem) {
    case pizza : @make_pizza_with_topping(last_slot);
    case uncooked_pizza : ~uncooked_pizza_message(last_slot);
    case default : @nothing_interesting_happens;
};


[proc,uncooked_pizza_message](int $last)
def_namedobj $ingredient = inv_getobj(inv, $last);
def_struct $struct = oc_param($ingredient, pizza_topping_struct);
mes("I need to cook this pizza before I can add <lowercase(struct_param($struct, productmessage))> to it.");
return;
//--------------------------------------------


[label,make_incomplete_pizza]
if (stat(cooking) < 35) {
    ~mesbox("You need a Cooking level of 35 to make a Pizza.");
}
//delete tomato and pizza base
inv_del(inv, tomato, 1);
inv_del(inv, pizza_base, 1);
//add incomplete pizza
inv_add(inv, incomplete_pizza, 1);
//display message
mes("You add the tomato to the pizza.");


[label,make_uncooked_pizza]
if (stat(cooking) < 35) {
    ~mesbox("You need a Cooking level of 35 to make a Pizza.");
}
//delete cheese and incomplete pizza
inv_del(inv, cheese, 1);
inv_del(inv, incomplete_pizza, 1);
//add uncooked pizza
inv_add(inv, uncooked_pizza, 1);
//display message
mes("You add the cheese to the pizza.");


[label,make_pizza_with_topping](int $last)
def_namedobj $ingredient = inv_getobj(inv, $last);
def_struct $struct = oc_param($ingredient, pizza_topping_struct);
//check if required level is met
if (stat(cooking) < struct_param($struct, levelrequired)) {
    ~mesbox("You need a Cooking level of <tostring(struct_param($struct, levelrequired))> to make a <struct_param($struct, levelfailmessage)>.");
}
//delete topping and pizza
inv_del(inv, $ingredient, 1);
inv_del(inv, pizza, 1);
//add pizza with topping
inv_add(inv, struct_param($struct, product), 1);
//give xp
givexp(crafting, struct_param($struct, productexp));
//display message
mes("You add the <struct_param($struct, productmessage)> to the pizza");