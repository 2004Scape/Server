[inv_button1,bank_main:inv] @bank_withdraw(last_slot, 1);
[inv_button2,bank_main:inv] @bank_withdraw(last_slot, 5);
[inv_button3,bank_main:inv] @bank_withdraw(last_slot, 10);
[inv_button4,bank_main:inv] @bank_withdraw(last_slot, ^max_32bit_int);
[inv_button5,bank_main:inv] @bank_withdraw(last_slot, null);
[inv_buttond,bank_main:inv] inv_movetoslot(bank, bank, last_slot, last_targetslot);
[if_button,bank_main:com_94] %bank_noted = 0;
[if_button,bank_main:com_93] %bank_noted = 1;
[if_close,bank_main] @closebank;

[label,openbank]
%bank_noted = 0;
~reorganize_bank;
inv_transmit(inv, bank_side:inv);
inv_transmit(bank, bank_main:inv);
if_openmainmodalsideoverlay(bank_main, bank_side);

[label,closebank]
~reorganize_bank;
inv_stoptransmit(bank_side:inv);
inv_stoptransmit(bank_main:inv);

[label,bank_withdraw](int $slot, int $requested_number)
// Check if the slot was empty.
def_obj $item = inv_getobj(bank, $slot);
// How many did they want to withdraw?
if ($requested_number <= 0) {
    p_countdialog;
    if (last_int <= 0) return;
    $requested_number = last_int;
}
// How many have they got?
def_int $number = inv_total(bank, $item);
// How many should we withdraw?
if ($requested_number < $number) $number = $requested_number;
// Okay, withdraw it from the bank.
~bank_withdraw_request(inv, $item, $number, $slot);

[proc,bank_withdraw_request](inv $inv, obj $obj, int $amount, int $slot)
def_obj $cert_or_uncert = oc_uncert($obj);
if (%bank_noted ! 0) {
    $cert_or_uncert = oc_cert($obj);
}

if (%bank_noted = ^true & oc_cert($obj) = $obj) {
    mes("This item can not be withdrawn as a note."); // 2005
}

if (inv_itemspace($inv, $obj, $amount, inv_size($inv)) = false){
    if (oc_stackable($obj) = true) {
        // https://youtu.be/8vNeG5bHg0Q?t=443
        mes("You're not going to be able to carry all that!");
    } else if (inv_freespace($inv) = 0) {
        // https://youtu.be/Zv7Wh3TIDOc?t=22
        mes("You don't have enough inventory space.");
        return;
    } else {
        // https://youtu.be/HnEZFSGbYqM?t=79
        mes("You don't have enough inventory space to withdraw that many.");
    }
}

def_int $overflow = inv_itemspace2($inv, $cert_or_uncert, $amount, inv_size($inv));
if (sub($amount, $overflow) > 0) {
    switch_int (%bank_noted) {
        case 0 : inv_moveitem_uncert(bank, $inv, $obj, sub($amount, $overflow));
        case default : inv_moveitem_cert(bank, $inv, $obj, sub($amount, $overflow));
    }
}

[proc,bank_deposit_request](inv $inv, obj $obj, int $amount, int $slot)
def_int $overflow = inv_itemspace2(bank, oc_uncert($obj), $amount, ^max_32bit_int);
if ($overflow >= $amount) {
    // https://youtu.be/2BgXLZD-xgo?t=28
    // https://youtu.be/Ep4gaI5ic1s?t=197
    mes("You don't have enough space in your bank account."); // osrs
    return;
}
inv_moveitem_uncert($inv, bank, $obj, sub($amount, $overflow));

[proc,bank_check_nobreak](obj $obj)(boolean)
if (~bank_find_obj_unbankable($obj) = true) {
    @a_magical_force_prevents_you_from_banking_this_item;
}

if (map_members = false) {
    // check for f2p bank limits.
    if ((inv_total(bank, oc_uncert($obj)) = 0) & (sub(inv_size(bank), inv_freespace(bank)) > ^bank_free_slots)) {
        @you_need_to_subscribe_for_a_members_account_if_you_want_to_store_any_more_items_in_the_bank;
    }
}
return(false);

[label,a_magical_force_prevents_you_from_banking_this_item]
mes("A magical force prevents you from banking this item!"); // osrs

// reorganize the bank like when you open the bank.
// this is because a player can move objs around in the bank
// to any slot that is available. so when they open the bank
// we reorganize all of the slots towards the left of the bank.
[proc,reorganize_bank]
def_int $size = inv_size(bank);
def_int $count = 0;

while ($count < $size) {
    def_int $slot_count = inv_getnum(bank, $count);

    if ($slot_count = 0) {
        def_int $peek_slot = ~bank_peek_next_available_obj_slot($count);

        if ($peek_slot = -1) {
            $count = add($size, 1);
        } else {
            inv_movetoslot(bank, bank, $peek_slot, $count);
            $count = add($count, 1);
        }
    } else {
        $count = add($count, 1);
    }
}

// used to check for any obj slots that are ahead of the input slot.
// returns the slot or -1 if none available.
[proc,bank_peek_next_available_obj_slot](int $from_slot)(int)
def_int $size = inv_size(bank);
def_int $count = $from_slot;
def_int $slot = -1;

while ($count < $size) {
    def_int $slot_count = inv_getnum(bank, $count);
    if ($slot_count = 0) {
        $count = add($count, 1);
    } else {
        $slot = $count;
        $count = add($size, 1);
    }
}
return($slot);

// returns if an obj is considered to be unbankable.
// experience lamps, quest items, etc.
[proc,bank_find_obj_unbankable](obj $obj)(boolean)
switch_obj ($obj) {
    case lamp : return(true); // cant bank xp lamps
    case default : return(false);
}
