[if_button,bank:com_94]
%bank_noted = 0;

[if_button,bank:com_93]
%bank_noted = 1;

[inv_button1,bank:inv] // 1
def_namedobj $obj = inv_getobj(bank, last_slot);
~withdraw_from_bank($obj, 1);

[inv_button2,bank:inv] // 5
def_namedobj $obj = inv_getobj(bank, last_slot);
~withdraw_from_bank($obj, 5);

[inv_button3,bank:inv] // 10
def_namedobj $obj = inv_getobj(bank, last_slot);
~withdraw_from_bank($obj, 10);

[inv_button4,bank:inv] // all
def_namedobj $obj = inv_getobj(bank, last_slot);
~withdraw_from_bank($obj, ^max_32bit_int);

[inv_button5,bank:inv] // x
def_namedobj $obj = inv_getobj(bank, last_slot);

[inv_buttond,bank:inv] // dragging obj
inv_swap(bank, last_slot, last_useslot);

[label,openbank]
~reorganize_bank;
inv_transmit(inv, bank_deposit:inv);
inv_transmit(bank, bank:inv);
if_opensub(bank, bank_deposit);

[proc,withdraw_from_bank](namedobj $obj, int $amount)
$amount = min($amount, inv_total(bank, $obj));

def_namedobj $cert_or_uncert = oc_uncert($obj);
if (%bank_noted ! 0) {
    $cert_or_uncert = oc_cert($obj);
}

def_int $overflow = inv_itemspace2(inv, $cert_or_uncert, $amount, inv_size(inv));
if ($overflow = $amount) {
    mes("You don't have enough inventory space."); // osrs
    return;
}

if ($overflow > 0) {
    // https://youtu.be/8vNeG5bHg0Q?t=443
    mes("You're not going to be able to carry all that!");
}
$amount = calc($amount - $overflow);

switch_int (%bank_noted) {
    case 0 : inv_moveitem_uncert(bank, inv, $obj, $amount);
    case default :
        if (oc_cert($obj) = $obj) {
            mes("This item cannot be withdrawn as a note."); // osrs
        }
        inv_moveitem_cert(bank, inv, $obj, $amount);
}

// reorganize the bank like when you open the bank.
// this is because a player can move objs around in the bank
// to any slot that is available. so when they open the bank
// we reorganize all of the slots towards the left of the bank.
[proc,reorganize_bank]
def_int $size = inv_size(bank);
def_int $count = 0;

while ($count <= $size) {
    def_int $slot_count = inv_getslotcount(bank, $count);

    if ($slot_count = 0) {
        def_int $peek_slot = ~bank_peek_next_available_obj_slot($count);

        if ($peek_slot = -1) {
            $count = calc($size + 1);
        } else {
            inv_swap(bank, $count, $peek_slot);
            $count = calc($count + 1);
        }
    } else {
        $count = calc($count + 1);
    }
}

// used to check for any obj slots that are ahead of the input slot.
// returns the slot or -1 if none available.
[proc,bank_peek_next_available_obj_slot](int $from_slot)(int)
def_int $size = inv_size(bank);
def_int $count = $from_slot;
def_int $slot = -1;

while ($count <= $size) {
    def_int $slot_count = inv_getslotcount(bank, $count);
    if ($slot_count = 0) {
        $count = calc($count + 1);
    } else {
        $slot = $count;
        $count = calc($size + 1);
    }
}
return($slot);

// returns if an obj is considered to be unbankable.
// experience lamps, quest items, etc.
[proc,bank_find_obj_unbankable](namedobj $obj)(boolean)
switch_namedobj ($obj) {
    case lamp : return(true); // cant bank xp lamps
    case default : return(false);
}
