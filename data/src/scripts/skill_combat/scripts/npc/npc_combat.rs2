[ai_queue1,_](int $arg) gosub(npc_default_retaliate);
[ai_queue2,_](int $damage) ~npc_default_damage($damage);
[ai_queue3,_](int $arg) gosub(npc_default_death);
[ai_opplayer2,_] gosub(npc_default_attack);

// a default melee retaliate script.
[proc,npc_default_retaliate]
if (finduid(%npc_attacking_uid) = false) {
    return;
}
// npc flinch
if (~npc_out_of_combat = true) {
    %npc_action_delay = add(map_clock, divide(npc_param(attackrate), 2));
}
npc_setmode(opplayer2);

// a default melee attack script.
[proc,npc_default_attack]
if (%npc_action_delay > map_clock) return;
anim(%com_defendanim, 0);

npc_anim(npc_param(attack_anim), 0);
sound_synth(npc_param(attack_sound), 0, 0);
~npc_meleeattack;

// a default damage script.
[proc,npc_default_damage](int $damage)
// if the npc is already dead
if (npc_stat(hitpoints) = 0) {
    return;
}
// damage the npc
if ($damage = 0) {
    npc_damage(^hitmark_block, 0);
} else {
    npc_damage(^hitmark_damage, $damage);
}
if (npc_stat(hitpoints) > 0) {
    return;
}
// if the npc died from this damage
npc_setmode(none);
npc_queue(3, 0, 0);

// a default death script.
[proc,npc_default_death]
gosub(npc_death);
def_obj $drop = npc_param(death_drop);
if ($drop ! null & npc_findhero = true) {
    obj_add(npc_coord, $drop, 1, 200);
}

[proc,npc_player_hit_roll](int $damagetype)(boolean)
def_int $attack_roll = ~npc_attack_roll_specific($damagetype);
def_int $defence_roll = ~player_defence_roll_specific($damagetype);
//mes("Clock: <tostring(map_clock)>, Player A: <tostring($attack_roll)>, NPC D: <tostring($defence_roll)>, Player Max: <tostring(%com_maxhit)>");
if (randominc($attack_roll) > randominc($defence_roll)) {
    return(true);
}
return(false);

[proc,npc_is_attackable](npc $npc)(boolean)
// this is a better way to do it but over the years osrs has had bugs where you could attack npcs that just had an op2 defined
// if (compare(nc_op($npc, 2), "Attack") = ^true) {
//     return (true);
// }
// so this way is more authentic, allows any npc with op2 defined to be attacked
if (string_length(nc_op($npc, 2)) > 0) {
    return (true);
}
return (false);

[proc,npc_out_of_combat]()(boolean)
if (add(%npc_action_delay, 8) < map_clock) {
    return (true);
}
return (false);

// returns the npc attack roll for this npc
// npcs only have one attackbonus.
[proc,npc_attack_roll]()(int)
if (~check_protect_prayer(^melee_style) = true) {
    return(0);
}
def_int $attackbonus = npc_param(attackbonus);
def_int $effective_attack = ~combat_effective_attack(1, npc_stat(attack), $attackbonus);
//npcs are essentially always on controlled
def_int $attack_roll = ~combat_melee_attack_roll($effective_attack, $attackbonus);
return($attack_roll);

// returns the defence roll for an attacking style.
[proc,npc_defence_roll_specific](int $damagetype)(int)
def_int $defencebonus = ~npc_combat_defencebonus($damagetype);
def_int $effective_defence = ~combat_effective_defence(1, npc_stat(defence), $defencebonus);
def_int $defence_roll = ~combat_melee_defence_roll($effective_defence, $defencebonus);
return($defence_roll);

[proc,npc_attack_roll_specific](int $damagetype)(int)
switch_int ($damagetype) {
    case ^stab_style, ^slash_style, ^crush_style: return(~npc_attack_roll);
    case ^ranged_style: return(~npc_ranged_attack_roll);
    case ^magic_style: return(~npc_magic_attack_roll);
}
return(0);

// get the npc bonus depending on the attacking style
[proc,npc_combat_defencebonus](int $style)(int)
switch_int ($style) {
    case ^stab_style: return(npc_param(stabdefence));
    case ^slash_style: return(npc_param(slashdefence));
    case ^crush_style: return(npc_param(crushdefence));
    case ^ranged_style: return(npc_param(rangedefence));
    case ^magic_style: return(npc_param(magicdefence));
}
error("style of <tostring($style)> not defined in switch for npc_combat_defencebonus");

//  this should be strong queued. Some damage is queued, some isnt
[queue,queue_damage_player](int $damage)
~damage_self($damage);